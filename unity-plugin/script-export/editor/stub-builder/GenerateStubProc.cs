using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using Microsoft.CodeAnalysis.Emit;
using UnityEditor;
using UnityEngine;

namespace WeChat {
    public class GenerateStubHelper {

        public static void Register(Action<string> callback) {
            GenerateStubProc.genUnityStubCallback = callback;
        }
    }
    internal class GenerateStubProc {

        public static Action<string> genUnityStubCallback;

        private static DirectoryStructure references;
        private static readonly string topHeader =  "//------------------------------------------------------------------------------ \n"     +
                                                    "// <auto-generated> \n"                                                                  +
                                                    "// Stub: {0} \n"                                                                         +
                                                    "// This stub code was generated by tool. \n"                                             +
                                                    "// \n"                                                                                   +
                                                    "// Changes to this file may cause unpredictable problems. \n"                            +
                                                    "// Changes will be also overwriten when the code is regenerated. \n"                     +
                                                    "// </auto-generated> \n"                                                                 +
                                                    "//------------------------------------------------------------------------------ \n\n"   ;

        private static readonly string refHeader = "//------------------------------------------------------------------------------ \n"   +
                                                   "// <auto-generated> \n"                                                                +  
                                                   "// Ref[{0}] ({1}) \n"                                                                  +
                                                   "// </auto-generated> \n"                                                               +
                                                   "//------------------------------------------------------------------------------ \n\n" ;

        [MenuItem("微信小游戏/调试/重新生成UnityEngine桩代码")]
        public static void GenePluginsStub() {
            // UnityEngine stub
            GeneUnityStub(true);

            // Other stub
            // var plugins = ConfigManager.configEntry.unityPluginConfig.unityPlugins;
            // plugins.Where(p => p.enable && p.pluginState == UnityPlugin.PluginState.stub && p.stubConfig.generateStub).ToList()
            //        .ForEach(p => {
            //         //     var outCSPath = PathUtil.GetPluginOutputPath(p, PathUtil.PluginOutputType.CS);
            //         //     var outCSRefPath = PathUtil.GetPluginOutputPath(p, PathUtil.PluginOutputType.CS, ".ref.cs");
            //         //     var outDLLPath = PathUtil.GetPluginOutputPath(p, PathUtil.PluginOutputType.DLL);
            //         //     var outJSPath = PathUtil.GetPluginOutputPath(p, PathUtil.PluginOutputType.JS);

            //         //    p.stubPath.stubCSPath = outCSPath;
            //         //    p.stubPath.stubRefCSPath = outCSRefPath;
            //         //    p.stubPath.stubDLLPath = outDLLPath;
            //         //    p.stubPath.stubJSPath = outJSPath;

            //            p.stubPath = new UnityPlugin.StubPath(p);

            //            GeneratePluginStub(p);
            //            Debug.Log("Generate Stub <" + p.pluginName + ">");
            //        });
        }

        public static void GeneUnityStub(bool overwrite = true) {
            var unity = UnityPluginUtil.GetUnityEngineStub();
            if (!overwrite && File.Exists(unity.stubPath.stubCSPath)) {
                Debug.LogWarning("UnityEngine Stub Exist.");
                return;
            }
            if (unity.stubConfig.generateStub) {
                // UnityStubBuilder.Build(unity.stubPath.stubCSPath);
                // 这里改用反射
                // UnityStubBuilder.cs 需要被单独作为c#源文件放出，编DLL时不能耦合
                // Type.GetType("WeChat.UnityStubBuilder").GetMethod("Build").Invoke(null, new object[] { unity.stubPath.stubCSPath });

                // 这里改用回调，DLL里调用反射拿不到C#源文件里定义的类，有空再查
                if(genUnityStubCallback != null) {
                    genUnityStubCallback.Invoke(unity.stubPath.stubCSPath);
                }
            }

            // header
            var allRefContent = string.Format(topHeader, unity.pluginName);
            
            string content = "";
            using (StreamReader sr = new StreamReader(unity.stubPath.stubCSPath)) {
                content = sr.ReadToEnd();
            }
            if (content == null || content == "" || content.Length == 0) {
                return;
            }

            using (var sw = new StreamWriter(unity.stubPath.stubCSPath, false)) {
                sw.Write(allRefContent);
                sw.Write(content);
            }

            var sources = new List<string>() { unity.stubPath.stubCSPath };
            var dir = new DirectoryInfo(Path.GetDirectoryName(unity.stubPath.stubDLLPath));
            if (!dir.Exists) {
                dir.Create();
            }
            var os = File.Create(unity.stubPath.stubDLLPath);

            if (references == null) {
                references = DirectoryBuilder.RegisterDirectory("references", new DirectoryStructure("References~"));
            }
            var refs = new List<string>() { references["Bridge"]["Bridge.dll"] };

            EmitResult result;
            try {
                result = DLLProc.BuildDLL("UnityEngine-stub", os, sources, unity.defineMacros,
                    refs, true);

            } finally {
                os.Close();
            }
            if (result == null || !result.Success) {
                throw new Exception();
            }
            Debug.Log("Generate Stub <UnityEngine>");
        }


        public static void GeneratePluginStub(UnityPlugin plugin) {
            if (plugin.pluginState != UnityPlugin.PluginState.stub) {
                return;
            }
            // Debug.Log("1");
            // 生成插件依赖的外部DLL的桩C#
            GeneratePluginRefStubCs(plugin);
            // 用unitydll和systemdll编译插件代码dll（有实现）
            GeneratePluginDLL(plugin);
            // 用上述dll的类型信息进行反射编桩c#代码（空实现）
            GeneratePluginStubCs(plugin);
            // 用所有桩c#编译桩DLL
            GeneratePluginStubDLL(plugin);
        }

        private static void GeneratePluginRefStubCs(UnityPlugin plugin) {
            if (!plugin.enable) return;

            var refs = UnityPluginUtil.GetLib(plugin);
            if (refs == null || refs.Count == 0) {
                Debug.Log(plugin.pluginName + ": References C# generating... no references found");
                return;
            }

            // header
            var allRefContent = string.Format(topHeader, plugin.pluginName);

            for (var i = 0; i < refs.Count; i++ ) {
                var r = refs[i];

                var refName = Path.GetFileNameWithoutExtension(r);
                Debug.Log(refName);
                var assembly = Assembly.LoadFile(r);
                var output = plugin.stubPath.stubRefCSPath;
                GeneratePluginRefStubCs(plugin.pluginName, output, assembly);

                var tmp = "";
                using (var sr = new StreamReader(output)) {
                    tmp = sr.ReadToEnd();
                }

                // remove #if UNITY_WAGAME
                //        using Bridge;
                //        using System;
                // at the begining of new ref stub content
                if (i > 0) {
                    tmp = String.Join("\n", tmp.Split('\n').Skip(4));
                }

                // remove #endif at last line
                tmp = tmp.Remove(tmp.TrimEnd().LastIndexOf(Environment.NewLine));

                // ref header
                allRefContent += string.Format(refHeader, i, refName);

                allRefContent += tmp;
                allRefContent += "\n\n";
            }
            // add #endif at the very last line
            allRefContent += "#endif";

            using (var sw = new StreamWriter(plugin.stubPath.stubRefCSPath, false)) {
                sw.Write(allRefContent);
            }
        }

        private static void GeneratePluginRefStubCs(string stubName, string output, Assembly assembly) {

            StubBuilder.Build(new StubOptions {
                stubName = stubName,
                outputPath = output, 
                whiteList = assembly.ExportedTypes, 
                filter = t => {
                    if (t == null) {
                        return false;
                    }
                    if (assembly.ExportedTypes.Contains(t)) {
                        return true;
                    }
                    return assembly.ExportedTypes.Contains(t.DeclaringType);
                }
            });
        }

        private static void GeneratePluginStubCs(UnityPlugin plugin) {
            if (!plugin.enable) return;

            var output = plugin.stubPath.stubCSPath;
            var dll = plugin.stubPath.stubDLLPath.Replace("-stub.dll", "-internal.dll");

            if (dll == null || dll == "") return;
            try {
                var assembly = Assembly.LoadFile(dll);
                StubBuilder.Build(new StubOptions {
                    stubName = plugin.pluginName,
                    outputPath = output, 
                    whiteList = assembly.ExportedTypes, 
                    filter = t => {
                        if (t == null) {
                            return false;
                        }
                        if (assembly.ExportedTypes.Contains(t)) {
                            return true;
                        }
                        return assembly.ExportedTypes.Contains(t.DeclaringType);
                    },
                    namespaceInterceptor = type => {
                        // 不允许没有 Namespace
                        if (type == null) { return Utils.NamespaceName; }
                        var ns = type.Namespace;
                        if (string.IsNullOrEmpty(ns)) { 
                            return Utils.NamespaceName; 
                        }
                        return null;
                }

                });
            } catch(FileNotFoundException e) {
                Debug.LogError(dll + " not exists");
            } catch(Exception ex) {
                Debug.LogError(ex);
            }

            // header
            var allRefContent = string.Format(topHeader, plugin.pluginName);
            
            string content = "";
            using (StreamReader sr = new StreamReader(output)) {
                content = sr.ReadToEnd();
            }
            if (content == null || content == "" || content.Length == 0) {
                return;
            }

            using (var sw = new StreamWriter(output, false)) {
                sw.Write(allRefContent);
                sw.Write(content);
            }
        }

        private static void GeneratePluginStubDLL(UnityPlugin config) {
            if (!config.enable) return;

            if (references == null) {
                references = DirectoryBuilder.RegisterDirectory("references", new DirectoryStructure("References~"));
            }

            var sources = new List<string>() { config.stubPath.stubCSPath };

            // Add refCS stub file
            var refCS = config.stubPath.stubRefCSPath;
            if (refCS != null && File.Exists(refCS)) {
                sources.Add(refCS);
            }
            
            var os = File.Create(config.stubPath.stubDLLPath);

            // var refs = UnityPluginUtil.GetLib(config, true, true);
            var refs = new List<string>() { references["Bridge"]["Bridge.dll"], UnityPluginUtil.GetUnityEngineStub().stubPath.stubDLLPath };
            if (refs == null || refs.Count == 0) return;

            EmitResult result;
            try {
                result = DLLProc.BuildDLL(config.pluginName + "-stub", os, sources, config.defineMacros,
                    refs, true);

            } finally {
                os.Close();
            }
            if (result == null || !result.Success) {
                throw new Exception();
            }
        }

        private static void GeneratePluginDLL(UnityPlugin config) {
            if (!config.enable) return;
            var sources = UnityPluginUtil.GetSource(config);
            var exc = UnityPluginUtil.GetExclude(config);
            sources = sources.Except(exc).ToList();
            if (sources == null || sources.Count == 0) return;
            
            var refs = UnityPluginUtil.GetLib(config, true, true);
            if (refs == null || refs.Count == 0) return;

            // rename dist dll
            var dist = config.stubPath.stubDLLPath.Replace("-stub.dll", "-internal.dll");
            var os = File.Create(dist);

            EmitResult result;
            try {  
                // comment this for TMP issue(internal visibility)
                result = DLLProc.BuildDLL(config.pluginName /* + "-internal" */, os, sources, config.defineMacros,
                    refs, true);
            } finally {
                os.Close();
            }
            if (result == null || !result.Success) {
                throw new Exception();
            }
        }

    }
}